# 指定した距離・角度だけ動く（オドメトリ） (C++)

[基本的な動作](./Home.md)

---

## オドメトリとは

- ロボットが自分の位置を把握する最も基本的な方法として、タイヤの回転数を使う方法がある。
- タイヤの直径が分かっていれば、ロータリエンコーダを使ってタイヤの回転数を計測することでどれだけの距離を進んだかを計算できる。
- このように、ロボットの内部状態を計測するセンサによって自己位置を推定することをオドメトリという。
- 精度は非常に低いことが多いが、広大で周囲に壁が無く、レーザなどの外界センサが使えない状況では役に立つこともある。
- ここでは、このオドメトリを使ってロボットが進んだ距離を計算し、一定距離だけ進むプログラムを作成する。

## 実習

[前項](./simple_move_cpp_01.md)で、`C++`ソース`simple_move.cpp`をダウンロード済みとして進める。

- `main`関数を次のように修正しなさい。

```c++
int main(int argc, char **argv)
{
    ros::init(argc, argv, "simple_move");
    ros::NodeHandle n;
    ros::Duration(1.0).sleep(); // 起動直後は rospy.Time.now() がゼロを返す．
    go_straight_by_distance(n, 1.0, 2.0); // 修正
}
```

### 実行順序

- まず、[シミュレータを起動する](../stage_simulator/stage_simulator_01.md)
- しばらくしてから`simple_move`を実行する。

```shell
$ rosrun beginner_tutorials simple_move
[INFO] [1632480750.849343, 60.675000]: Executing go_straight_by_distance
```

- 起動したら、コマンドターミナルの画面をよく観察すること。オドメトリによる座標情報が出力されるはずである。

## 問題

### 問題（１）

- `go_straight_by_distance`関数を完成させなさい。
  - 仮引数`distance`で指定した距離だけ進むようにする。手順は次の通り。
    1. `while`文に入る前に、ロボットのオドメトリによる現在地を取得し、局所変数に記憶しておく。つまり、動作の開始地点。
    2. 繰り返しのたびに、`x`、`y`と、動作の開始地点との距離を計算し、それが`distance`以上になったとき、`break`で`while`ループを抜ける。
  - 仮引数`time_limit`は直進の制限時間を表しているが、`main`関数で使用する際は`go_straight_by_distance(n, 1.0, 30.0)`のように長めにしておくこと。
  - `rospy.loginfo`を使った出力では、次のようにどれだけ進んだかも表示すること。

```shell
・・・
[INFO] [1634615851.715154, 1147.450000]: Recv odometry. (x, y, theta) d = (8.14, 0.92, 89.42) 0.93 # 0.93m進んだ
[INFO] [1634615851.957260, 1147.675000]: Recv odometry. (x, y, theta) d = (8.15, 1.01, 89.42) 1.02
```

### 問題（２）

- `go_straight_by_distance`関数をコピーし、`turn_by_angle`という、指定した角度だけ旋回する関数を作りなさい。
  - 引数名は変えた方が良い（`linear_vel`：直進速度、`angular_vel`：回転速度）。
  - 回転速度のデフォルト値は`30度/秒`とする。

```c++
void turn_by_angle(ros::NodeHandle& n, double angle, double time_limit=999, double angular_vel=???, const std::string&topic="/odom", const std::string&cmd_vel="/cmd_vel", double msg_wait=1.0); // 初期値はどうする？
```

- 角度の場合は距離のときと異なり、－180度～＋180度で表現される点に注意が必要です。
- 例えばロボットが左周りにずっと回転し、＋180度を超えたとき、ロボットの姿勢は－179度、－178度・・・0度、＋1度・・・というように変化します。
- 従って、距離のときと同じように最初の姿勢を覚えておいて、現在の姿勢から単に引き算しただけでは失敗するケースがあり、簡単なようで却って複雑になります。
- 最も簡単な方法は1フレームごとに回転した角度を積分して行き、目標角を超えた時点で終了させることです。
- ロボットの現在の姿勢の角度（ラジアン）を得る`get_yaw`関数を使用してください。
- フレームごとのヨー角（真上から見たロボットの向き。下記コードでは変数`yaw`）が得られたとき、前フレームでのヨー角（下記コードでは変数`yaw_pre`）との差分を次のコードで計算し、その絶対値を累積していってください。

```c++
double yaw = get_yaw(odom);
double d = fabs(angles::normalize_angle(yaw - yaw_pre));
// d に１フレームで回転した角度の絶対値が入っている。これを累積する。
yaw_pre = yaw
```

### 問題（３）

- `turn_by_angle`、`go_straight_by_distance`を使って、ロボットを四角形を描くように移動させてみよう。直進->90 度回転->直進・・・。時計回りに動いてから反時計回りに動くなど。
  - シミュレーションのロボットは自分の都合の良い位置に自由に移動させて構わない。
- 作成したプログラムを実機でも試してみよう。

---

[基本的な動作](./Home.md)
